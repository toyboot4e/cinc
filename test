#!/usr/bin/env bash
#
# Tests run via `make test` (via Docker)

cd "$(dirname "$0")"

TO_ASM='./obj/cinc'
ROOT="$(pwd)"

i_test=0

# CAUTION: the expected value must be in [0, 255], i.e. the range of exit status
assert() {
    expected="$1"
    input="$2"

    asm="$(printf './obj/%02d.s' "$i_test")"
    obj='./obj/tmp'

    i_test=$((i_test+1))

    # Generate assembly file
    "$TO_ASM" "$input" > "$asm"
    status="$?"
    if [ $status -ne 0 ] ; then
        echo "Failed to compile code \`$input\` with error code \`$status\`";
        exit 1
    fi

    # Create machine code and run
    cc "$asm" -o "$obj"
    "$obj"
    actual="$?"

    if [ "$actual" = "$expected" ]; then
        echo "ok: \`$input\` => $actual"
    else
        echo "err: \`$input\` => $expected expected, got $actual"
        exit 1
    fi
}

assert 0 '0;'
assert 42 '42;'

assert 21 '5+20-4;'
assert 41 ' 12 + 34 - 5 ;'

assert 47 '5 + 6 * 7;'
assert 15 '5 * (9 - 6);'
assert 4 '(3 + 5) / 2;'

# unary operator
assert 15 '-(-3 * +5);'
assert 10 '- - +10;'
assert 10 '-10+20;'
assert 10 '- -10;'

# comparison
assert 1 '0<1;'
assert 0 '1<1;'
assert 0 '2<1;'
assert 1 '0<=1;'
assert 1 '1<=1;'
assert 0 '2<=1;'

assert 1 '1>0;'
assert 0 '1>1;'
assert 0 '1>2;'
assert 1 '1>=0;'
assert 1 '1>=1;'
assert 0 '1>=2;'

# multiple expressions
assert 1 '3 + 4; 4 <= 6;'

# one-character statements
assert 12 'a = 10; a + 2;'
assert 24 'a = 10; b = 12; a + b + 2;'

# multi-character statements
assert 6 'a_var = 1; b_var = 2; a_var + 3 + b_var;'

# return statement
assert 3 'return 3; 5;'

echo 'all tests passed'

